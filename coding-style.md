# Coding Style

## Выравнивание и отступы

Выравнивание необходимо для облегчения чтения кода.

- Отступ - 2 пробела. Табы `\t` запрещены.
```systemverilog
  statement_1
    statement_2 
```

- Круглые скобки оформляются так: `if( a )`: пробелы ставятся после открывающейся
  скобки и условия. Перед открывающеся скобкой пробел не ставится.

- Более сложный пример: 
```systemverilog
if( ( a == 5 ) && ( c > 8 ) )
```
Пробелами отделяется каждое из логических условий, причем, те условия которые находятся 
внутри `if` тоже отделяются пробелами.

- Пример выравнивания `if/else`

```systemverilog
if( a > 5 )
  d = 5;
else
  d = 15;
```

- Пример выравнивания `if/else` вместе с `begin/end`

```systemverilog
if( a > 5 )
  begin
    c = 7;
    d = 5;
  end
else
  begin
    c = 3;
    d = 7;
  end
```

- Пример выравнивания вложенного `if/else`

```systemverilog
if( a > 5 )
  c = 7;
else
  if( a > 3 )
    c = 4;
  else 
    c = 5;
```

- Следует стремиться выравнивать их названия, размерность и комментарии. 

Неправильно:

```systemverilog
// BAD EXAMPLE
logic rd_stb; //buffer read strobe
logic [31:0] ram_data; //data from RAM block
logic [1:0]if_mode; //interface mode
```

Правильно:

```systemverilog
// GOOD EXAMPLE
logic        rd_stb;    // buffer read strobe
logic [31:0] ram_data;  // data from RAM block
logic [1:0]  if_mode;   // interface mode
```

- Офорление оператора `case`

Каждый из вариантов описывается в своем `begin/end` блоке, отделяя
варианты друг от друга пустой строкой.

```systemverilog
case( opcode[1:0] )
  2'b00:
    begin
      next_state = or_s;
    end

  2'b01:
    begin
      next_state = and_s;
    end

  2'b10:
    begin
      next_state = not_s;
    end

  2'b11:
    begin
      next_state = xor_s;
    end

  default:
    begin
      next_state = and_s;
    end
endcase
``` 

Если `case` простой и не подразумевает никаких вложенных конструкций в `begin/end` блоке, 
то допускается для уменьшения строк делать так:

```systemverilog
case( opcode[1:0] )
  2'b00:   next_state = or_s;
  2'b01:   next_state = and_s;
  2'b10:   next_state = not_s;
  2'b11:   next_state = xor_s;
  default: next_state = and_s;
endcase
```

Заметьте, что здесь выровнено по `next_state` для облегчения чтения.

- Еще один пример выравнивания:
```systemverilog
if( condition1 )
  begin
    for( int i = 0; i < 10; i = i + 1 )
      statement1;
  end
else 
  if( condition2 )
    statement2;
  else
    if( condition3 )
      statement3;
    else
      statement4;
```

## Комментарии
Комментарии пишутся на английском языке.
После знака комментария `//` ставится один пробел.

## Наименование переменных и модулей

- Стиль названия переменных, функций, тасков и модулей - `snake_case`, т.е. слова или префиксы
  разделяются `_`, и всё пишется маленькими буквами.

  Пример:
    - `pkt_anlz`
    - `is_ptp_pkt`
    - `super_task`
  
- Большими буквами (но через `_`) пишутся только константы:
  - параметры: `parameter`, `localparam`
  - дефайны: `define`
  - состояния FSM

- Имя переменной должно отражать ее назначение. 
  Следует избегать чрезмерно длинных и, особенно, чрезмерно коротких названий (`rd_addr` лучше чем `ra`).

- Названия портов должны содержать суффикс `_i` для входных, `_o` для выходных, `_io` для 
  двунаправленных сигналов.

## Описание конечного автомата (FSM)
- Переменные, которые используются в качестве символических имен состояний FSM , должны содержать суффикс `_s` 
   ( `IDLE_S`, `TX_S`, `WAIT_S` etc.)

## Описание клоков
- Входной синхросигнал по умолчанию должен называться `clk_i`.

## Описание сбросов
- Вход асинхронного сброса должен называться `rst_i`; 
   категорически запрещается называть `rst_i` синхронный сброс; 
   для названия синхронного сброса (например для возвращения FSM в состояние idle_s) 
   следует использовать имя "srst_i".

## Размещение исходников

Исходники размещаются в файлах. Правило простое:
один модуль, package, интерфейса - один файл. Название файла - название этого модуля. 

- Расширения:
  - Verilog: `.v`.
  - SystemVerilog: `.sv`.
  - Verilog Header: `vh`
  - SystemVerilog Header: `svh`.
  - VHDL: `.vhd`.

- Файлы содержащие только декларации package следует помечать окончанием _pkg: `func_pkg.sv`
- Файлы содержащие только константами, функции, таски, которые подгружаются в исходник при помощи include, следует именовать расширением .vh Пример
`defines.vh`.


## Описание и объявление модулей

### Описание модуля
Каждый модуль описывается в отдельном файле.

```systemverilog
module some_module #(
  parameter DATA_WIDTH = 32,
  parameter CNT_WIDTH  = 8
)(
  input                         clk_i,
  input                         rst_i,

  input        [DATA_WIDTH-1:0] data_i,
  input                         data_val_i,

  output logic [CNT_WIDTH-1:0]  cnt_o
);

// some code...

endmodule
```

Т.е.:
  - Описание параметров и сигналов начинается с отступа (2 пробела).

  - При описании параметров и сигналов всё выравнивается. 

  - Сигналы не смешиваются в кучу, те сигналы, которые формируют логический интерфейс
    интерфейсы должны разделяться пустой строкой.

  - Предпочтительно сначала описывать входные сигналы, потом выходные, однако,
    первочердным должен соблюдаться принцип интерфейсов, который описан выше.

  - Первым в описании сигналов должно идти описание клоков и сбросов.  

### Инстанс модуля

```systemverilog
some_module #(
  .DATA_WIDTH                             ( 64                ),
  .CNT_WIDTH                              ( 4                 )
) some_module (
  .clk_i                                  ( rx_clk            ),
  .rst_i                                  ( main_rst          ),

  .data_i                                 ( rx_data           ),
  .data_val_i                             ( rx_data_val       ),

  .cnt_o                                  ( cnt               )
);  
```

Т.е.:
  - При подключении сигнала или переопределении параметра делается отступ (2 пробела).

  - Cкобки, точки, запятые выравниваются.

  - Для передачи параметров используется `#`, а не `defparam`.

  - Пустые строчки, которые отделяют логические интерфейсы (или сигналы, которые должны быть вместе) так же
    как и в описании модуля.

  - Чаще всего зкземпляр модуля называется так же как сам модуль; если экземпляров одного модуля несколько, 
    то их названия дополняются суффиксами `_inst0`, `_inst1` ( либо просто `0`, `1` ) и т.д. 
    Однако иногда названия получается слишком длинные и засчет вложенности модулей иерархический
    путь может быть очень длинным, что приведет к неудобству смотрения в ModelSim или TimeQuest.
    Поэтому допускается инстансы(!) модулей типа: `main_engine` сокращать до `me`. Однако без
    необходимости этим не злоупотреблять.

## Описание переменных

- Переменные в модулей "создаются" после описания сигналов модуля и до начала "работы" с этими сигналами.

```systemverilog
  output logic abc_o
);

logic [7:0]  cnt;
logic        cnt_en;

logic [63:0] pkt_data;
// ... some more signals

// some work with signal starts here
```

  Это делается для того, чтобы это было в одном месте.

- Связанные переменные, как и сигналы модуля необходимо логически отделять пустой строкой. 

- Допускается создавать сигналы "рядом" с тем местом, где они употребляются, например:
```systemverilog
logic [2:0] vlan_mpls_cnt;
// more signals

// some code
always_comb
  begin
    if( vlan_mpls_cnt > 2 )
      ...
  end

// calc vlan_mpls_cnt
logic [1:0] vlan_cnt;
logic [1:0] mpls_cnt;

assign vlan_cnt = vlan[0] + vlan[1] + vlan[2];
assign mpls_cnt = mpls[0] + mpls[1] + mpls[2];

assign vlan_mpls_cnt = vlan_cnt + mpls_cnt;
```

## Синтаксические конструкции

- При описании с помощью блока always комбинационной схемы, схемы содержащей
  регистры или защелки (latch) следует использовать соответственно блоки
  always_comb, always_ff или always_latch. Данное правило позволит избежать
  ошибок в описании (компилятор выдаст error) и сделает описание более компактным
  (к примеру, не будет надобности указывать список чувствительности для
  комбинационной логики).

- Категорически запрещается реализовывать в устройствах сигналы с нулевым
  активным уровнем. Исключением могут быть стандартные интерфейсы, где такие
  сигналы изначально предусмотрены (sram interface к примеру). Допускается
  наличие подобных сигналов на входах FPGA, но на верхнем уровне иерархии они
  должны быть проинвертированы.

- При наличии двунаправленных шин, направления передачи должны развязываться на
  верхнем уровне иерархии.

- В RTL описаниях использовать тип logic (за исключением тех случаев, когда
  необходимы множественные драйверы). Это позволит выявить ошибки, связанные с
  множественным назначением на этапе компиляции и ошибки, вызванные отсутствием
  инициализации (так как logic инициализируется неопределенным значением).

- Настоятельно рекомендуется записывать в регистры все валидные выходные сигналы. Это повысит максимальную скорость работы устройства.

- Все критичные к быстродействию узлы по возможности следует размещать в
  отдельном модуле. Это позволит оптимизировать его независимо от прочих узлов.

- При описании комбинационных схем (always_comb) использовать только блокирующие назначения `a = b`.

- При описании схем, содержащих регистры (always_ff), использовать только неблокирующие назначения `a <= b`.

- Все макроподстановки (`define) должны определяться в отдельном файле либо в
  модуле верхнего уровня иерархии.

- Hard-code недопустим и, по возможности, модули должны быть параметризованы.
  Исключения возможны в тех случаях, когда параметризуемость делает программу
  менее читабельной и понятной. Главное требование - модуль не должен требовать
  допиливания после присвоения нового значения параметру, т.е. должен полностью
  сохранять функционал. 
